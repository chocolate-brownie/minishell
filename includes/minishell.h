/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   minishell.h                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mgodawat <mgodawat@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/04/17 16:00:52 by mgodawat          #+#    #+#             */
/*   Updated: 2025/06/10 12:46:12 by mgodawat         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#ifndef MINISHELL_H
# define MINISHELL_H

# include "../libft/includes/libft.h"
# include "colors.h"
# include "error.h"
# include "exec.h"
# include "heredoc.h"
# include <curses.h>
# include <dirent.h>
# include <fcntl.h>
# include <readline/history.h>
# include <readline/readline.h>
# include <limits.h>
# include <signal.h>
# include <stdio.h>
# include <stdlib.h>
# include <sys/ioctl.h>
# include <sys/stat.h>
# include <sys/types.h>
# include <sys/wait.h>
# include <term.h>
# include <termios.h>
# include <unistd.h>

# define PROMPT "minishell â†’ "
# define DEBUG 0

/*
** Defines the types of tokens that can be identified by the lexer.
** Each token type corresponds to a specific syntactic element of the shell
** command language, such as words, operators (pipe, redirections), or EOF.
*/
typedef enum e_token_type
{
	TOKEN_WORD,
	TOKEN_PIPE,
	TOKEN_REDIR_IN,
	TOKEN_REDIR_OUT,
	TOKEN_REDIR_APPEND,
	TOKEN_REDIR_HEREDOC,
	TOKEN_EOF
}								t_token_type;

/*
** Represents a lexical token generated by the lexer. Each token stores its
** string value and its `t_token_type`. Tokens are organized as a linked list
** to represent the sequence of elements in a parsed command line.
*/
typedef struct s_token
{
	char						*value;
	t_token_type				type;
	struct s_token				*next;
}								t_token;

/*
** Encapsulates parameters used for iterating over characters within a command
** string, particularly useful when handling quoted segments. It holds a pointer
** to the command string, a pointer to the current index, and the quote
** character being processed (if any).
*/
typedef struct s_char_iter_params
{
	const char					*cmd_str;
	int							*idx_ptr;
	char						q_char;
}								t_char_iter_params;

/*
** Stores parameters required to determine the finishing condition or position
** when parsing a quoted string. It includes the command string, the current
** index, and the specific quote character that initiated the quoted section.
*/
typedef struct s_quote_finish_params
{
	const char					*cmd_str;
	int							idx;
	char						q_char;
}								t_quote_finish_params;

/*
** Holds parameters for initializing the process of extracting values from
** quoted or unquoted segments of a command string. This includes the command
** string, current position, output for accumulated value, iterator parameters,
** an index, and the detected quote character.
*/
typedef struct s_quote_extract_init_params
{
	const char					*command;
	int							*position;
	char						**accumulated_value_out;
	t_char_iter_params			*iter_params_out;
	int							*i_out;
	char						*quote_char_out;
}								t_quote_extract_init_params;

/*
** Helper structure for get_quoted_val to manage its local variables
** and stay within Norminette's 5-variable limit per function.
*/
typedef struct s_quote_val_params
{
	char						quote_char;
	char						*accumulated_value;
	int							i;
	int							loop_status;
}								t_quote_val_params;

/*
** Represents a single environment variable. It stores the variable's identifier
** (name), its value, and the raw string (e.g., "ID=value") from which it was
** parsed. Environment variables are stored in a linked list.
*/
typedef struct s_env
{
	char						*id;
	char						*value;
	char						*raw;
	struct s_env				*next;
}								t_env;

/*
** Central structure holding the overall state and context of the minishell.
** This includes the environment variables, last exit code, command execution
** data (parsed commands, PIDs), I/O backup FDs, heredoc management information,
** the token list from the lexer, and error status flags.
*/
typedef struct s_context
{
	t_env						*envp;
	int							last_exit_code;
	int							should_exit;
	t_exec						*command_list;
	pid_t						*pids;
	int							pid_count;
	int							stdin_backup;
	int							stdout_backup;
	int							heredoc_counter;
	t_hd_temp_file				*active_heredocs;
	t_token						*token_list;
	int							has_syntax_error;
}								t_context;

extern volatile sig_atomic_t	g_signal;

/*
** ------------------- Lexer ------------------------------------
*/
/*
** Performs lexical analysis on the input command string.
** It breaks down the raw command into a sequence of tokens,
** identifying words, operators, and other significant lexical units.
*/
t_token							*lexer(const char *cmd, t_context *ctx);
int								validate_input(const char *cmd, t_context *ctx);
void							init_token_list(t_token **list_head,
									t_token **list_tail);

/*
** ------------------- Lexer Utils ------------------------------
*/

int								is_quote(char c);
int								is_delimiter(char c);
t_token							*get_next_token(const char *cmd, int *i,
									t_context *ctx);
t_token							*create_token(char *value, t_token_type type);
void							free_token_list(t_token *token_list);
void							append_token(t_token **head, t_token **tail,
									t_token *token);
char							*append_char(char *str, char c, t_context *ctx);
int								find_closing_quote(const char *cmd,
									int start_pos);
char							*append_extracted(char *accumulated_value,
									char *value, t_context *ctx);
char							*handle_quotes(const char *cmd, int *index,
									t_context *ctx);
t_token							*handle_word(const char *cmd, int *i,
									t_context *ctx);
int								process_char_in_quoted_val(
									t_char_iter_params *params,
									char **accumulated_value, t_context *ctx);
int								process_char_in_unquoted_val(
									const char *command, int *i,
									char **accumulated_value, t_context *ctx);
char							*get_quoted_val(const char *command,
									int *position, t_context *ctx);
char							*get_unquoted_val(const char *command,
									int *position, t_context *ctx);
int								append_eof_token(t_token **list_head,
									t_token **list_tail, t_context *ctx);
int								handle_backslash_dq(t_char_iter_params *params,
									char **val_ptr, t_context *ctx);
char							*append_char(char *str, char c, t_context *ctx);

/*
** ------------------- Lexer Env Var Utils -------------------
*/
int								is_valid_var_char_start(char c);
int								is_valid_var_char_subsequent(char c);
char							*extract_env_var_name(const char *cmd_str,
									int *idx_ptr);
int								process_backslash_unquoted(const char *command,
									int *i, char **accumulated_value,
									t_context *ctx);
int								handle_unquoted_dollar_q(int *i,
									char **accumulated_value, t_context *ctx);
int								handle_unquoted_regular_char(
									const char *command, int *i,
									char **accumulated_value, t_context *ctx);
/*
** ------------------- Parser -----------------------------------
*/
/*
** Constructs a command structure from the token list.
** It takes the sequence of tokens produced by the lexer and organizes
** them into a hierarchical representation of commands, arguments,
** and redirections, suitable for execution.
*/
t_exec							*parser(t_token *token_list, t_context *ctx);

/*
** ------------------- Parser Utils -----------------------------
*/
int								validate_init_tokens(t_token *token_list,
									t_context *ctx);
void							link_nodes(t_exec **head, t_exec **tail,
									t_exec *new_node);
int								check_next_tok(t_token **curr_tok,
									t_context *ctx);
void							invalseg_after_pipe(t_exec **headptr,
									t_exec **newptr, t_token **startptr,
									t_context *ctxptr);
void							free_exec_list(t_exec *head);
t_redir_type					get_redir_type(t_token_type type);
t_exec							*create_exec_node(t_token **token_ptr,
									t_context *ctx);
void							free_single_exec_node_content(t_exec *node);
void							token_failure(t_exec *new_node, t_context *ctx);
void							unexpected_token(t_exec *new_node,
									t_token *curr_tok, t_context *ctx);
t_redirs						*append_redir(t_redirs **redir_list_head,
									t_redir_type type, char *path,
									t_context *ctx);
int								process_word_token(t_exec *exec_node,
									t_token **curr, t_context *ctx);
void							free_structs(char *errmsg, t_token *ptr_tkn,
									t_exec *ptr_exec);
t_args							*create_arg_node(char *value, t_context *ctx);
t_args							*append_arg(t_args **args_list_head,
									char *value, t_context *ctx);
int								process_redir_token(t_exec *cmd_node,
									t_token **curr_token_ptr, t_context *ctx);
t_redir_type					get_exec_redir_type_from_token(
									t_token_type token_type);
int								handle_invalid_token_syntax(t_token *file_token,
									t_context *ctx);

/*
** ------------------- Expander ---------------------------------
*/
/*
** Handles the expansion of the "$?" special shell variable.
** This function replaces "$?" with the exit status of the last
** executed command. Other expansions (e.g., environment variables)
** are typically handled within lexer utils during word processing
** (e.g., inside handle_quotes).
*/
char							*expand_dollar_question(char *acc_val,
									int *cmd_idx_ptr, t_context *ctx);
char							*expand_heredoc_line(char *line,
									t_context *ctx);
int								process_single_heredoc_line(char *line_read,
									t_heredoc_data *hdata, t_context *ctx);

/*
** ------------------- Expander Utils ---------------------------
*/
/*
** (Currently, no specific utility functions are listed solely for the
** expander category beyond what's integrated into lexer word processing.
** General expansion mechanisms are part of `handle_quotes` and related
** lexer utilities.)
*/

/*
** ------------------- Execution --------------------------------
*/
/*
** Manages the execution of a full command pipeline.
** This involves setting up pipes, forking processes for each command
** in the pipeline, handling I/O redirections, and waiting for all
** child processes to complete.
*/
int								execute_pipeline(t_context *ctx);
int								ft_cd(t_exec *cmd, t_env *env);
int								ft_echo(t_exec *cmd);
int								ft_pwd(void);
int								ft_env(t_env *env);
int								ft_export(t_env *env, t_exec *cmd);
int								ft_unset(t_env **env, t_exec *cmd);
void							process_unset_argument(char *arg, t_env **env,
									int *return_status, int *malloc_error_flag);
int								ft_exit(t_exec *cmd, t_context *ctx);

/*
** ------------------- Execution Utils --------------------------
*/
long long						ft_atol_with_error(char *str, int *error_flag);
void							set_error_message_and_exit_code(t_context *ctx,
									char **args, int type);

void							process_unset_argument(char *arg, t_env **env,
									int *return_status, int *malloc_error_flag);

int								redir_input(t_redirs *redir);
int								redir_output(t_redirs *redir);
int								redir_append(t_redirs *redir);
void							execute_command(t_resources *res,
									t_context *ctx);
void							handle_command_error(t_exec *cmd,
									t_resources *res, t_context *ctx);
int								execute_single_builtin(t_exec *cmd,
									t_context *ctx);
pid_t							cmd_loop(t_exec *cmd, t_context *ctx,
									int *prev_read_end, int pipefd[2]);
int								wait_for_childrens(pid_t last_pid);
int								handle_redir(t_exec *cmd, t_context *ctx);
int								restore_stdio(t_context *ctx);
char							**args_to_array(t_exec *cmd,
									int include_cmd_name);
char							*get_cmd_path(char **envp, char *cmd);
pid_t							fork_and_execute(t_context *ctx, t_exec *cmd,
									int pipefd[2], int prev_read_end);
int								is_builtin(t_exec *cmd);
int								execute_builtin(t_exec *cmd, t_context *ctx,
									t_env *env);
int								create_pipe_if_needed(t_exec *cmd,
									int pipefd[2]);
void							child_execute_external_command(t_context *ctx,
									t_exec *cmd);
void							free_tab(char **array);
void							free_child(t_resources *res, t_context *ctx);
void							print_signal_msg(int status,
									int *message_printed);
void							setup_signal_parent(void);
void							setup_signal_child(void);

/*
** ------------------- Heredoc ----------------------------------
*/
/*
** Manages "here document" (heredoc) processing for input redirection.
** It reads input lines from the user until a specified delimiter is
** encountered, typically storing this input in a temporary file
** to be used as standard input for a command.
*/
char							*handle_heredoc(t_token **curr_token_ptr,
									t_context *ctx);

/*
** ------------------- Heredoc Utils ----------------------------
*/
int								read_heredoc_input(t_heredoc_data *hdata,
									t_context *ctx);
int								heredoc_delim_validation(t_context *ctx,
									t_token *delim_token);
void							init_heredoc_struct(t_heredoc_data *hdata);
int								hd_tempfile(t_context *ctx, int count,
									char **path_out);
void							cleanup_hd_resources(t_heredoc_data *hdata);
void							add_active_heredoc(t_context *ctx,
									const char *filepath);
void							remove_and_unlink_active_heredoc(
									t_context *ctx, const char *filepath);
void							cleanup_all_active_heredocs(t_context *ctx);
int								handle_eof_case(t_heredoc_data *hdata);
int								handle_heredoc_interrupt(char *line_read,
									struct sigaction *sa_old_int,
									t_context *ctx);
void							restore_old_signals(
									struct sigaction *sa_old_int);
void							setup_heredoc_signals(
									struct sigaction *sa_heredoc_int,
									struct sigaction *sa_old_int);
int								handle_sigint_case_for_heredoc(char *line_read,
									t_context *ctx);
void							heredoc_sigint_handler(int sig);
void							handle_char_output(char c, int *current_len);
int								process_char(char c, char *buffer,
									int *current_len);
void							cleanup_command_heredocs(t_exec *exec_list,
									t_context *ctx);

/*
** ------------------- Environment Management -------------------
*/
/*
** Initializes and populates the shell's internal list of environment
** variables from the parent process's environment array (envp).
*/
t_env							*populate_env_list(char **original_envp,
									t_context *ctx);
/*
** Initializes the environment variables list, potentially from a base set
** or an empty state if not populating from an existing envp.
*/
t_env							*init_env(char **envp);
/*
** Retrieves the value of an environment variable specified by its ID (name).
*/
char							*get_env_value(t_env *env, char *id);

/*
** ------------------- Environment Management Utils -------------
*/
void							free_env_list(t_env *env_list_head);
void							free_env(t_env *env);
t_env							*env_new_node(char *id, char *value, char *raw);
int								update_env_var(t_env *env, char *id,
									char *new_value);
char							**env_to_envp(t_env *env);

/*
** ------------------- Signal Handling --------------------------
*/
/*
** Configures the primary signal handlers for the minishell process.
** This typically includes handlers for SIGINT (Ctrl+C) and SIGQUIT (Ctrl+\)
** to manage interactive shell behavior and interruptions.
*/
int								setup_signal_handlers(t_context *ctx);

/*
** ------------------- Main Shell Functions & Other Utilities ---
*/
/*
** The main operational loop of the minishell.
** It handles prompting the user, reading input, processing commands
** (lexing, parsing, execution), and managing the overall shell state
** until termination.
*/
int								run_minishell(t_context *ctx);
int								execute_command_list(t_exec *exec_list,
									t_context *ctx);
/*
** Reads a line of command input from the user.
** Often utilizes a library like readline for enhanced input editing
** capabilities and command history.
*/
char							*read_cmd(t_context *ctx);
/*
** Performs comprehensive cleanup of the shell's global context (t_context)
** and all associated resources before the shell exits.
*/
void							cleanup_tcontext(t_context *ctx);
/*
** General cleanup for resources like command string, token list, etc.,
** often called after each command cycle or on error.
*/
void							cleanup_resources(char *cmd,
									t_token *token_list, t_context *ctx);
/*
** Frees all globally managed resources within the context, typically
** called at the very end or during major error recovery.
*/
void							free_all(t_context *ctx);
int								cleanup_after_sigint(char *cmd,
									t_token **token_list);
int								cleanup_failed_exec(char *cmd,
									t_token **token_list);
int								check_state(int argc, char *argv[]);
int								clear_term(t_context *ctx);
void							set_exit_code(t_context *ctx, int exit_code,
									char *errmsg);

/*
** ------------------- Debugging functions ----------------------
*/
void							print_tokens(char *cmd, t_token *list_head);
void							print_exec_list(t_exec *exec_list_head);

int								setup_terminal_mode(struct termios *old_term,
									struct termios *new_term);
void							restore_terminal_mode(struct termios *old_term);

#endif
